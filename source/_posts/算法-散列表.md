---
title: 算法-散列表
date: 2021-07-12 10:00:42
tags:
categories:
---



# 散列表

散列表（Hash table，也叫哈希表）



# 哈希函数（映射）

<font color=red>根据Key来计算存储位置的计算规则我们称之为哈希函数</font>

假如我们有一组数据,某位工程师每年的收入情况

```bash
2017 -- 100000
2018 -- 130000
2019 -- 140000
2020 -- 200000
```

```bash
1. 新建一个长度为2020的数组array[]
2. 根据H(x) = x 计算存储位置，将数据放入数组中。
   array[2017] = 100000
   array[2018] = 130000
   array[2019] = 140000
   array[2020] = 200000
3. 查询2019年收入情况时，通过H(x) = x 计算出存储位置，直接取出数据array[2019]
```

## 直接定址法

**Hash（Key）= A\*Key + B**。
优点：简单、均匀
缺点：需要事先知道关键字的分布情况(<font color=red>判断其对应关系是否为线性</font>)



## 除留余数法

**Hash( key ) = key % p ( p <= m)**

m为地址数

p为一个不大于m，但最接近或者等于m的质数







# 散列表的运作流程

输入要查找的值key，使用 Hash(key) 得到一个值i

若 array[i] = key ，则查找成功

若 array[i] 不存在，则插入元素，返回 ”查找失败“

若 array[i] ≠ key，则进行哈希冲突处理









# 哈希冲突

哈希函数算出来的位置已有元素, 即为冲突



# 冲突处理

## 线性探查法

<font  color=red>产生冲突，依次查看其后的下一个桶，如果发现空位置插入新元素</font>



![image-20210712101645062](https://picgo-freejim.oss-cn-beijing.aliyuncs.com/to_upload/image-20210712101645062.png)





## 平方探测法(二次探测法)【+】

相对比上面的i+1, 平方探测法为 i+(平方序列)

<font color=red >平方序列: </font>

1, -1, 4, -4, 9, -9

线性探测容易聚集，二次探测聚集情况较线性探测要好

散列表长度是某个4k＋3形式的素数时，平方探测法就可以探查到整个散列表空间

![image-20210712104248398](https://picgo-freejim.oss-cn-beijing.aliyuncs.com/to_upload/image-20210712104248398.png)

插入20

h(20)=8冲突

+1冲突，-1冲突

+4 (9+4)%11=2 无冲突‘

冲突次数=3



## 链地址法

开散列法又叫**链地址法**(开链法)

![image-20211010155225930](https://picgo-freejim.oss-cn-beijing.aliyuncs.com/to_upload/image-20211010155225930.png)

![image-20211010155233200](https://picgo-freejim.oss-cn-beijing.aliyuncs.com/to_upload/image-20211010155233200.png)











# 载荷因子（装填因子、装载因子）

满1

**散列表的载荷因子：a = 插入元素个数n / 散列表的长度m**

a是散列表装满程度的标志因子。

**散列表的平均查找长度**依赖于散列表的装填因子

而不直接依赖于n和m



## 装填因子与平均查找长度

装填因子越大，散列表越满，越容易发生冲突

装填因子越小，越不容易发生冲突，平均查找长度就越小

<font color=red>散列表不满，容易查找不成功，但是其查找长度就是短了呀</font>

（array[i] 若不存在则插入并返回”查找失败“）





# 散列表的效率



## 影响因素

散列函数、处理冲突的方法、装填因子

散列表的平均查找长度依赖于散列表的装填因子

